
1, 每个线程都有一个boolean类型的中断状态，当中断线程时，这个线程的中断状态将被设置为true,在thread中包含了中断线程以及查询线程中断状态的方法.
interrupt方法能中断目标线程，而isInterrupt方法能返回目标线程的中断状态，静态的interrupted方法将清除当前线程的中断状态，并返回它之前的值
这也是清除中断状态的唯一方法

2,阻塞库方法，例如Thread.sleep和Object.wait等，都会检查线程何时中断，并且在发现中断时提前返回。它们在响应中断时执行的操作包括：清除中断状态，
抛出InterruptedException,表示阻塞操作由于中断而提前结束.JVM并不能保证阻塞方法检测到中断的速度，但在实际情况中响应速度还是非常快的.
当线程在非阻塞状态下中断时，它的中断状态将被设置，然后根据将被取消的操作来检查中断状态已判断发生了中断。通过这样的方法，中断操作将变得"有粘性"--如果不触发
InterruptedException,那么中断状态将一直保持，直到明确地清除中断状态.

调用interrupt并不意味着立即停止目标线程正在进行的工作，而只是传递了请求中断的消息

对中断操作的正确理解是：它并不会真正地中断一个正在运行的线程，而只是发出中断请求，然后由线程在下一个合适的时刻中断自己。（这些时刻也被称为取消点）。
有些方法，例如wait,sleep和join等，将严格地处理这种请求，当它们收到中断请求或者在开始执行时发现某个已被设置好的中断状态时，将抛出一个异常。
设计良好的方法可以完全忽略这种请求。只要它们能使调用代码对中断请求进行某种处理。设计糟糕的方法可能会屏蔽中断请求，从而导致调用栈中的其他代码无法对
中断请求做出相应。

在使用静态的interrupted时应该小心，因为它会清除当前线程的中断状态。如果在调用interrupted时返回了true,那么除非你想屏蔽这个中断，否则必须对它进行处理
可以抛出InterruptedException，或者通过再次调用interrupt来恢复中断状态.